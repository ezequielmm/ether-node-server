import { Injectable } from '@nestjs/common';
import { ReturnModelType } from '@typegoose/typegoose';
import { InjectModel } from 'kindagoose';
import { Seeder } from 'nestjs-seeder';
import { ContestMap } from './contestMap.schema';
import {
    addHoursToDate,
    countSteps,
    findStepWithMostNodes,
    setHoursMinutesSecondsToUTCDate,
} from 'src/utils';
import { ContestService } from '../contest/contest.service';
import { MapBuilderService } from '../map/builder/mapBuilder.service';
import { createStage1NewMap } from '../map/builder/actOne.config';
import { SettingsService } from '../components/settings/settings.service';
import { IActConfiguration } from '../map/builder/mapBuilder.interface';
import { createStage2NewMap } from '../map/builder/actTwo.config';

@Injectable()
export class ContestMapSeeder implements Seeder {
    constructor(
        @InjectModel(ContestMap)
        private readonly contestMap: ReturnModelType<typeof ContestMap>,
        private readonly mapBuilderService: MapBuilderService,
        private readonly contestService: ContestService,
        private readonly settingsService: SettingsService,
    ) {}

    public defaultName = 'Default Contest';

    async seed(): Promise<any> {
    
        const { maxAutogeneratedMapSteps, maxAutogeneratedMapNodes, numberOfStages } = await this.settingsService.getSettings();

        let stages: string[] = [];

        for(let i = 0; i < numberOfStages; i++){
            
            let actConfig: IActConfiguration;
            
            switch(i){
                case 0:
                    actConfig = createStage1NewMap(maxAutogeneratedMapSteps, maxAutogeneratedMapNodes);
                    break;
                case 1:
                    actConfig = createStage2NewMap(maxAutogeneratedMapSteps, maxAutogeneratedMapNodes);
                    break;
                default:
                    console.log("--------------------------------------------------------------------------------------------------")
                    console.log("Entered a stage switch option that shouldn't.")
                    console.log(numberOfStages)
                    console.log("--------------------------------------------------------------------------------------------------")
            }

            const map = await this.mapBuilderService.createMap({
                actConfig: actConfig,
                makeAvailable: true
            });

            const contestMap = await this.contestMap.create({
                name: `${this.defaultName} Map - Stage: ${1 + i}`,
                nodes: map,
                maxSteps: maxAutogeneratedMapSteps,
                maxNodes: findStepWithMostNodes(map),
                isGenerated: true,
            });

            stages[i] = contestMap.id;
        }

        const today = new Date();
        const availableAt = setHoursMinutesSecondsToUTCDate(today);
        const endsAt = setHoursMinutesSecondsToUTCDate(
            availableAt,
            23,
            59,
            59,
            999,
        );
        const validUntil = addHoursToDate(endsAt, 6);

        const event_id = await this.contestService.getLastEventId();

        // Now we schedule the contest to the day
        const contest = await this.contestService.create({
            stages: stages,
            event_id: event_id + 1,
            available_at: availableAt,
            ends_at: endsAt,
            valid_until: validUntil,
            name: this.defaultName
        });

        return contest;
    }

    async drop(): Promise<any> {
        await this.contestService.deleteMany({});
        return await this.contestMap.deleteMany({});

        // const today = new Date();
        // const availableAt = setHoursMinutesSecondsToUTCDate(today);
        // const endsAt = setHoursMinutesSecondsToUTCDate(
        //     availableAt,
        //     23,
        //     59,
        //     59,
        //     999,
        // );

        // const mapFound = await this.contestService.findOne({
        //     name: this.defaultName,
        //     created_at: { $gte: availableAt },
        //     ends_at: { $lte: endsAt }
        // });

        // if (mapFound) {
        //     await this.contestService.deleteMany({map_id: mapFound.id });
        //     return await this.contestMap.deleteMany({ _id: mapFound.id });
        // }
        // return;
    }
}
